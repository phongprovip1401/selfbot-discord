import { readFileSync, writeFileSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import axios from 'axios';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const BANKS_PATH = path.join(__dirname, '../banks.json');
const USER_BANKS_PATH = path.join(__dirname, '../userbanks.json');
const BANKS_PER_PAGE = 15;

// ƒê·∫£m b·∫£o file userbanks.json t·ªìn t·∫°i v√† c√≥ c·∫•u tr√∫c ƒë√∫ng
try {
    const data = readFileSync(USER_BANKS_PATH, 'utf8');
    if (!data) {
        writeFileSync(USER_BANKS_PATH, JSON.stringify({ accounts: {} }, null, 2));
    } else {
        const parsed = JSON.parse(data);
        if (!parsed.accounts) {
            writeFileSync(USER_BANKS_PATH, JSON.stringify({ accounts: {} }, null, 2));
        }
    }
} catch (err) {
    writeFileSync(USER_BANKS_PATH, JSON.stringify({ accounts: {} }, null, 2));
}

export const name = 'qr';
export const permission = 'everyone';

export async function execute(message, args) {
    if (!args.length) {
        return '‚ùå Vui l√≤ng nh·∫≠p option! V√≠ d·ª•:\n;qr id <t·ª´ kh√≥a>\n;qr edit <id bank> <s·ªë t√†i kho·∫£n> <t√™n ch·ªß t√†i kho·∫£n>\n;qr bank <s·ªë ti·ªÅn> [n·ªôi dung]\n;qr clear | x√≥a t√†i kho·∫£n ng√¢n h√†ng hi·ªán t·∫°i';
    }

    const option = args[0].toLowerCase();

    if (option === 'id') {
        if (!args[1]) {
            return '‚ùå Vui l√≤ng nh·∫≠p t·ª´ kh√≥a! V√≠ d·ª•: ;qr id mb';
        }

        try {
            const banksData = JSON.parse(readFileSync(BANKS_PATH, 'utf8'));
            const keyword = args.slice(1).join(' ').toLowerCase();
            const filteredBanks = banksData.banks.filter(bank => 
                bank.code.toLowerCase().includes(keyword) ||
                bank.shortName.toLowerCase().includes(keyword) ||
                bank.name.toLowerCase().includes(keyword)
            );

            if (filteredBanks.length === 0) {
                return '‚ùå Kh√¥ng t√¨m th·∫•y ng√¢n h√†ng n√†o ph√π h·ª£p!';
            }

            // Format k·∫øt qu·∫£ t√¨m ki·∫øm
            let response = '```\nK·∫øt qu·∫£ t√¨m ki·∫øm cho: ' + keyword + '\n';
            response += 'ID | Code | Short Name | Name\n';
            response += '-'.repeat(50) + '\n';

            filteredBanks.forEach(bank => {
                response += `${bank.id.toString().padEnd(3)} | ${bank.code.padEnd(6)} | ${bank.shortName.padEnd(12)} | ${bank.name}\n`;
            });

            response += `\nT√¨m th·∫•y ${filteredBanks.length} k·∫øt qu·∫£\`\`\``;
            
            const sent = await message.channel.send(response);
            setTimeout(() => sent.delete().catch(() => {}), 30000);
            return;
        } catch (err) {
            console.error('L·ªói khi ƒë·ªçc file banks.json:', err);
            return '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch ng√¢n h√†ng!';
        }
    }

    if (option === 'bank') {
        if (args.length < 2) {
            return '‚ùå Thi·∫øu th√¥ng tin! C√∫ ph√°p: ;qr bank <s·ªë ti·ªÅn> [n·ªôi dung]';
        }

        try {
            // ƒê·ªçc th√¥ng tin t√†i kho·∫£n c·ªßa user
            let userBanksData = { accounts: {} };
            try {
                const data = readFileSync(USER_BANKS_PATH, 'utf8');
                if (data) {
                    userBanksData = JSON.parse(data);
                    if (!userBanksData.accounts) {
                        userBanksData.accounts = {};
                    }
                }
            } catch (err) {
                // N·∫øu file kh√¥ng t·ªìn t·∫°i ho·∫∑c l·ªói, t·∫°o c·∫•u tr√∫c m·ªõi
                userBanksData = { accounts: {} };
            }

            const userId = message.author.id;
            const userAccount = userBanksData.accounts[userId];

            if (!userAccount) {
                return '‚ùå B·∫°n ch∆∞a thi·∫øt l·∫≠p t√†i kho·∫£n ng√¢n h√†ng! D√πng l·ªánh ;qr edit ƒë·ªÉ th√™m t√†i kho·∫£n.';
            }

            // L·∫•y s·ªë ti·ªÅn v√† n·ªôi dung
            const amount = parseInt(args[1].replace(/[,.]/g, '')); // Lo·∫°i b·ªè d·∫•u ph·∫©y v√† ch·∫•m
            if (isNaN(amount) || amount <= 0) {
                return '‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!';
            }

            const content = args.slice(2).join(' ') || 'Chuyen tien'; // N·ªôi dung m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥

            // T·∫°o QR cho t√†i kho·∫£n
            const qrUrl = `https://img.vietqr.io/image/${userAccount.bankCode}-${userAccount.accountNumber}-compact2.png?amount=${amount}&addInfo=${encodeURIComponent(content)}&accountName=${encodeURIComponent(userAccount.accountName)}`;
            
            try {
                const response = await axios.get(qrUrl, { responseType: 'arraybuffer' });
                const qrFile = {
                    attachment: Buffer.from(response.data),
                    name: `qr_${userAccount.bankCode}_${userAccount.accountNumber}.png`
                };

                // T·∫°o tin nh·∫Øn v·ªõi th√¥ng tin chuy·ªÉn kho·∫£n
                const infoMessage = `üí≥ **Th√¥ng tin chuy·ªÉn kho·∫£n**\n` + 
                    `**${userAccount.bankName}**\nS·ªë TK: \`${userAccount.accountNumber}\`\nT√™n TK: \`${userAccount.accountName}\`` +
                    `\n\nS·ªë ti·ªÅn: \`${amount.toLocaleString('vi-VN')} VNƒê\`\nN·ªôi dung: \`${content}\``;

                // G·ª≠i tin nh·∫Øn v√† h√¨nh QR
                await message.channel.send({
                    content: infoMessage,
                    files: [qrFile]
                });
                return;

            } catch (err) {
                console.error('L·ªói khi t·∫°o QR:', err);
                return '‚ùå C√≥ l·ªói x·∫£y ra khi t·∫°o m√£ QR!';
            }

        } catch (err) {
            console.error('L·ªói khi ƒë·ªçc th√¥ng tin t√†i kho·∫£n:', err);
            return '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin t√†i kho·∫£n!';
        }
    }
    if (option === 'clear') {
        try {
            // Reset file v·ªÅ c·∫•u tr√∫c ban ƒë·∫ßu
            writeFileSync(USER_BANKS_PATH, JSON.stringify({ accounts: {} }, null, 2));
            const reply = await message.channel.send('‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ t√†i kho·∫£n v√† reset file v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu');
            setTimeout(() => {
                message.delete().catch(() => {});
                reply.delete().catch(() => {});
            }, 5000);
            return;
        } catch (err) {
            console.error('L·ªói khi x√≥a t√†i kho·∫£n:', err);
            const reply = await message.channel.send('‚ùå C√≥ l·ªói x·∫£y ra khi x√≥a t√†i kho·∫£n!');
            setTimeout(() => {
                message.delete().catch(() => {});
                reply.delete().catch(() => {});
            }, 5000);
            return;
        }
    }

    if (option === 'edit') {
        // Ki·ªÉm tra ƒë·ªß tham s·ªë
        if (args.length < 4) {
            return '‚ùå Thi·∫øu th√¥ng tin! C√∫ ph√°p: ;qr edit <id bank> <s·ªë t√†i kho·∫£n> <t√™n ch·ªß t√†i kho·∫£n>';
        }

        const bankId = parseInt(args[1]);
        const accountNumber = args[2];
        // Gh√©p c√°c ph·∫ßn c√≤n l·∫°i l√†m t√™n ch·ªß t√†i kho·∫£n
        const accountName = args.slice(3).join(' ');

        try {
            // Ki·ªÉm tra id bank c√≥ t·ªìn t·∫°i
            const banksData = JSON.parse(readFileSync(BANKS_PATH, 'utf8'));
            const bank = banksData.banks.find(b => b.id === bankId);
            
            if (!bank) {
                return '‚ùå ID ng√¢n h√†ng kh√¥ng t·ªìn t·∫°i! D√πng l·ªánh ;qr id ƒë·ªÉ t√¨m ID ng√¢n h√†ng.';
            }

            // ƒê·ªçc d·ªØ li·ªáu t√†i kho·∫£n ng∆∞·ªùi d√πng
            let userBanksData = { accounts: {} };
            try {
                const data = readFileSync(USER_BANKS_PATH, 'utf8');
                if (data) {
                    userBanksData = JSON.parse(data);
                    if (!userBanksData.accounts) {
                        userBanksData.accounts = {};
                    }
                }
            } catch (err) {
                // N·∫øu file kh√¥ng t·ªìn t·∫°i ho·∫∑c l·ªói, t·∫°o c·∫•u tr√∫c m·ªõi
                userBanksData = { accounts: {} };
            }

            // L∆∞u th√¥ng tin t√†i kho·∫£n m·ªõi
            const userId = message.author.id;
            const isUpdate = userBanksData.accounts[userId] !== undefined;

            // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o m·ªõi t√†i kho·∫£n
            userBanksData.accounts[userId] = {
                bankId,
                bankCode: bank.code,
                bankName: bank.shortName,
                accountNumber,
                accountName
            };

            // L∆∞u v√†o file
            try {
                writeFileSync(USER_BANKS_PATH, JSON.stringify(userBanksData, null, 2));
                //console.log('ƒê√£ l∆∞u v√†o file:', userBanksData); // Th√™m log ƒë·ªÉ ki·ªÉm tra
            } catch (err) {
                console.error('L·ªói khi l∆∞u file:', err);
                throw err;
            }

            const reply = await message.channel.send(`‚úÖ ƒê√£ ${isUpdate ? 'c·∫≠p nh·∫≠t' : 'th√™m'} t√†i kho·∫£n:\nNg√¢n h√†ng: ${bank.shortName}\nS·ªë TK: ${accountNumber}\nT√™n TK: ${accountName}`);
            setTimeout(() => {
                message.delete().catch(() => {});
                reply.delete().catch(() => {});
            }, 5000);
            return;

        } catch (err) {
            console.error('L·ªói khi l∆∞u th√¥ng tin t√†i kho·∫£n:', err);
            const reply = await message.channel.send('‚ùå C√≥ l·ªói x·∫£y ra khi l∆∞u th√¥ng tin t√†i kho·∫£n!');
            setTimeout(() => {
                message.delete().catch(() => {});
                reply.delete().catch(() => {});
            }, 5000);
            return;
        }
    }

    return '‚ùå Option kh√¥ng h·ª£p l·ªá! C√°c option c√≥ s·∫µn: id, edit, bank';
} 